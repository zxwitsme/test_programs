.\"
.\" @(#)lmbench.man	2.0 98/04/24
.\"
.\"   lmbench - benchmarking toolbox
.\"
.\"   Copyright (C) 1998  Carl Staelin and Larry McVoy
.\"   E-mail: staelin@hpl.hp.com
.\"
.TH "lmbench reporting" 3 "$Date" "(c)1998 Larry McVoy" "LMBENCH"
.SH "NAME"
milli, micro, nano, mb, kb \- the lmbench reporting subsystem
.SH "SYNOPSIS"
.ft C
#include "lmbench.h"
.br
void	milli(char *s, uint64 n);
.br
void	micro(char *s, uint64 n);
.br
void	nano(char *s, uint64 n);
.br
void	mb(uint64 bytes);
.br
void	kb(uint64 bytes);
.ft R
.SH "DESCRIPTION"
Creating benchmarks using the 
.I lmbench 
timing harness is easy.
Since it is so easy to measure performance using 
.IR lmbench , 
it is possible to quickly answer questions that arise during system
design, development, or tuning.  For example, image processing 
.P
There are two attributes that are critical for performance, latency 
and bandwidth, and 
.IR lmbench 's 
timing harness makes it easy to measure and report results for both.  
The measurement interface, 
.B BENCH 
and 
.BR BENCH1 , 
are identical, but the reporting functions are different.
Latency is usually important for frequently executed operations, and
bandwidth is usually important when moving large chunks of data.
.TP
.B "void	milli(char *s, uint64 n)"
print out the time per operation in milli-seconds.  
.I n 
is the number of operations during the timing interval, which is passed 
as a parameter because each
.I loop_body
can contain several operations.
.TP
.B "void	micro(char *s, uint64 n)"
print the time per opertaion in micro-seconds.
.TP
.B "void	nano(char *s, uint64 n)"
print the time per operation in nano-seconds.
.TP
.B "void	mb(uint64 bytes)"
print the bandwidth in megabytes per second.
.TP
.B "void	kb(uint64 bytes)"
print the bandwidth in kilobytes per second.
.SH "FUTURES"
Development of 
.I lmbench 
is continuing.  
.SH "SEE ALSO"
lmbench(3), timing(3), results(3).
.SH "AUTHOR"
Carl Staelin and Larry McVoy
.PP
Comments, suggestions, and bug reports are always welcome.
